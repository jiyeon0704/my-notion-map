<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>ë…¸ì…˜ ì„ë² ë“œìš© í•€ ì§€ë„ (ë ˆì´ì•„ì›ƒ ìµœì¢… ìˆ˜ì •)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Firebase (ëª¨ë“ˆ) -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, collection, addDoc, updateDoc, deleteDoc, doc, onSnapshot, serverTimestamp, query, where, getDocs, writeBatch, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

/********** 1. ì„¤ì • **********/
const MAP_IMAGE_URL = "https://jiyeon0704.github.io/info_map/mapsarboretum.png";
const MIN_ZOOM = -5, MAX_ZOOM = 5; 
const firebaseConfig = {
  apiKey: "AIzaSyB1r9RKhbbgXMvUFh3s69f1Lt5xIYr8t6U",
  authDomain: "infomap-52f57.firebaseapp.com",
  projectId: "infomap-52f57",
  storageBucket: "infomap-52f57.firebasestorage.app",
  messagingSenderId: "1039788996752",
  appId: "1:1039788996752:web:1ebca93b29d79033638015",
  measurementId: "G-WSB5TL789R"
};
const COLLECTION_PATH = 'infomap_pins';
const TYPES_DOC_ID = '--pin-types--';

let PIN_TYPES = [];

/********** 2. ì „ì—­ ë³€ìˆ˜ **********/
let map, db;
const markerMap = new Map();
let selectedId = null;
let isEditMode = false;
let initialBounds = null; 

// ì´ë¯¸ì§€ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
function getImageSize(url){
  return new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => res({ w: img.naturalWidth, h: img.naturalHeight });
    img.onerror = () => rej(new Error("ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨"));
    img.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
  });
}

// ë§ˆì»¤ ì•„ì´ì½˜ ìƒì„±
function createMarkerIcon(titleText) {
  const root = document.createElement('div');
  root.className = 'marker-root';
  root.innerHTML = `<div class="marker-label">${titleText || '(ë¯¸ì„ íƒ)'}</div><div class="marker-dot"></div>`;
  return L.divIcon({ html: root.outerHTML, className: '', iconSize: [22, 22], iconAnchor: [11, 11] });
}

// ëª¨ë“  ë§ˆì»¤ ìŠ¤íƒ€ì¼ ì´ˆê¸°í™” (ê¹œë¹¡ì„, íë¦¼ ì œê±°)
function resetAllMarkerStyles() {
    markerMap.forEach(rec => {
        if (rec.el) {
            rec.el.classList.remove('marker-blink', 'marker-faded');
        }
    });
}

// íŠ¹ì • ë§ˆì»¤ ê·¸ë£¹ ê¹œë¹¡ì„ + ë‚˜ë¨¸ì§€ íë¦¬ê²Œ
function highlightMarkers(markersToBlink) {
    resetAllMarkerStyles(); 
    
    const blinkMarkerIds = new Set();
    markersToBlink.forEach(marker => {
        for (const [id, rec] of markerMap.entries()) {
            if (rec.marker === marker) {
                blinkMarkerIds.add(id);
                break;
            }
        }
    });

    markerMap.forEach((rec, id) => {
        if (blinkMarkerIds.has(id)) {
            if (rec.el) rec.el.classList.add('marker-blink');
        } else {
            if (rec.el) rec.el.classList.add('marker-faded');
        }
    });
}

// í•€ ì„ íƒ/í•´ì œ
function selectMarker(id) {
  if (selectedId && markerMap.has(selectedId)) {
    const prev = markerMap.get(selectedId);
    if (prev.el) prev.el.classList.remove('marker-selected');
    const li = document.querySelector(`.pin-child-item[data-id="${selectedId}"]`);
    if (li) li.classList.remove('active');
  }
  selectedId = id;
  const typeSelect = document.getElementById('typeSelect');
  if (id && markerMap.has(id)) {
    const rec = markerMap.get(id);
    if (rec.el) rec.el.classList.add('marker-selected');
    const li = document.querySelector(`.pin-child-item[data-id="${id}"]`);
    if (li) li.classList.add('active');
    const currentTitle = rec.data.title || '';
    typeSelect.value = PIN_TYPES.includes(currentTitle) ? currentTitle : "";
    typeSelect.disabled = !isEditMode;
  } else {
    typeSelect.value = "";
    typeSelect.disabled = true;
  }
}

// ë§ˆì»¤ ì¶”ê°€
function addMarkerFromDoc(id, data) {
  if (markerMap.has(id)) return;
  const icon = createMarkerIcon(data.title);
  const marker = L.marker([data.lat, data.lng], { icon, draggable: isEditMode }).addTo(map);
  const el = marker.getElement();
  el.dataset.markerId = id; 
  
  marker.on('click', (e) => { L.DomEvent.stopPropagation(e); resetAllMarkerStyles(); selectMarker(id); });
  marker.on('dragend', async () => { 
    const p = marker.getLatLng();
    await updateDoc(doc(db, COLLECTION_PATH, id), { 
        lat: p.lat, 
        lng: p.lng, 
        updatedAt: serverTimestamp() 
    });
  });
  markerMap.set(id, { marker, el, data });
}

// ë§ˆì»¤ ì—…ë°ì´íŠ¸
function updateMarkerFromDoc(id, data) {
  const rec = markerMap.get(id);
  if (!rec) { addMarkerFromDoc(id, data); return; }
  rec.data = data;
  rec.marker.setLatLng([data.lat, data.lng]);
  rec.marker.setIcon(createMarkerIcon(data.title));
  rec.el = rec.marker.getElement(); 
  rec.el.dataset.markerId = id; 
  if (selectedId === id) selectMarker(id);
}

// ë§ˆì»¤ ì‚­ì œ
function removeMarker(id) {
  const rec = markerMap.get(id);
  if (!rec) return;
  rec.marker.remove();
  markerMap.delete(id);
  if (selectedId === id) selectMarker(null);
}

// ê·¸ë£¹í™”ëœ ëª©ë¡ ìƒˆë¡œê³ ì¹¨ (ê²€ìƒ‰ ê¸°ëŠ¥ ì¶”ê°€)
function refreshList() {
  const listEl = document.getElementById('pinItems');
  const totalCountEl = document.getElementById('totalPinCount');
  const searchInput = document.getElementById('pinSearchInput');
  const searchTerm = searchInput.value.toLowerCase();
  listEl.innerHTML = '';
  const groupedPins = {};
  let totalCount = 0;
  markerMap.forEach((rec, id) => {
      totalCount++;
      const type = rec.data.title || '(ë¯¸ë¶„ë¥˜)';
      if (!groupedPins[type]) {
          groupedPins[type] = [];
      }
      groupedPins[type].push({ id, ...rec });
  });
  totalCountEl.textContent = totalCount; 
  Object.entries(groupedPins)
    .sort((a, b) => a[0].localeCompare(b[0]))
    .filter(([type, pins]) => {
        return type.toLowerCase().includes(searchTerm);
    })
    .forEach(([type, pins]) => {
      const groupLi = document.createElement('li');
      groupLi.className = 'pin-group';
      const header = document.createElement('div');
      header.className = 'pin-group-header';
      header.innerHTML = `
          <span class="title">${type}</span>
          <span class="pin-group-count">${pins.length}ê°œ</span>
      `;
      const childrenUl = document.createElement('ul');
      childrenUl.className = 'pin-group-children hidden';
      pins.forEach(pin => {
          const childLi = document.createElement('li');
          childLi.className = 'pin-child-item';
          childLi.dataset.id = pin.id;
          if (pin.id === selectedId) childLi.classList.add('active');
          childLi.innerHTML = `
              <span class="title">â”” (Y: ${pin.data.lat.toFixed(0)}, X: ${pin.data.lng.toFixed(0)})</span>
              <div class="actions">
                  <button class="delete-pin-btn" title="ì‚­ì œ">ğŸ—‘ï¸</button>
              </div>
          `;
          
          childLi.onclick = (e) => {
              if (!e.target.closest('.actions')) {
                  resetAllMarkerStyles(); 
                  selectMarker(pin.id);
                  map.flyTo([pin.data.lat, pin.data.lng], 3.5, { duration: 1.5 }); 
              }
          };
          const deleteBtnLi = childLi.querySelector('.delete-pin-btn');
          deleteBtnLi.onclick = async (e) => {
              e.stopPropagation();
              if (!isEditMode) { alert("í¸ì§‘ ëª¨ë“œë¥¼ ì¼œì£¼ì„¸ìš”."); return; }
              await deleteDoc(doc(db, COLLECTION_PATH, pin.id));
          };
          childrenUl.appendChild(childLi);
      });
      
      header.onclick = () => {
          childrenUl.classList.toggle('hidden');
          
          const markersInGroup = pins
              .map(pin => markerMap.get(pin.id)?.marker)
              .filter(Boolean); 
          
          if (markersInGroup.length > 0) {
              resetAllMarkerStyles(); 
              selectMarker(null); 
              
              if (initialBounds) {
                   map.fitBounds(initialBounds, { animate: true }); 
              }
              
              highlightMarkers(markersInGroup); 
          }
      };
      
      groupLi.appendChild(header);
      groupLi.appendChild(childrenUl);
      listEl.appendChild(groupLi);
    });
}

// í¸ì§‘ ëª¨ë“œ í† ê¸€
function toggleEditMode(enable) {
  isEditMode = enable;
  document.getElementById('app').classList.toggle('edit-mode', enable);
  markerMap.forEach(rec => {
    if (rec.marker.dragging) {
      enable ? rec.marker.dragging.enable() : rec.marker.dragging.disable();
    }
  });
  selectMarker(selectedId);
  renderManageList();
}

// Firestoreì— ì¢…ë¥˜ ëª©ë¡ ì €ì¥
async function savePinTypes() {
    await setDoc(doc(db, COLLECTION_PATH, TYPES_DOC_ID), { list: PIN_TYPES });
}

// ì¢…ë¥˜ ëª©ë¡ UI ê°±ì‹ 
function refreshTypeOptions() {
    const typeSelect = document.getElementById('typeSelect');
    typeSelect.innerHTML = '<option value="">(í•€ì„ ì„ íƒí•˜ì„¸ìš”)</option>';
    PIN_TYPES.forEach(type => {
        const opt = document.createElement('option');
        opt.value = type;
        opt.textContent = type;
        typeSelect.appendChild(opt);
    });
    if (selectedId && markerMap.has(selectedId)) {
         const currentTitle = markerMap.get(selectedId).data.title;
         if (PIN_TYPES.includes(currentTitle)) typeSelect.value = currentTitle;
    }
    renderManageList();
}

// ê´€ë¦¬ ëª©ë¡ ë Œë”ë§
function renderManageList() {
    const list = document.getElementById('typeManageList');
    list.innerHTML = '';
    PIN_TYPES.forEach(type => {
        const li = document.createElement('li');
        li.innerHTML = `
            <span class="type-name">${type}</span>
            <div class="type-actions">
                <button class="rename-type-btn" ${!isEditMode ? 'disabled' : ''}>âœï¸</button>
                <button class="delete-type-btn" ${!isEditMode ? 'disabled' : ''}>ğŸ—‘ï¸</button>
            </div>
        `;
        li.querySelector('.rename-type-btn').onclick = () => {
            if (!isEditMode) return;
            const nameSpan = li.querySelector('.type-name');
            const actionsDiv = li.querySelector('.type-actions');
            const originalName = nameSpan.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = originalName;
            input.className = 'inline-type-input';
            const saveRename = async () => {
                const newName = input.value.trim();
                if (newName && newName !== originalName) {
                    if (PIN_TYPES.includes(newName)) {
                        alert("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì´ë¦„ì…ë‹ˆë‹¤.");
                        renderManageList();
                        return;
                    }
                    input.disabled = true;
                    const q = query(collection(db, COLLECTION_PATH), where("title", "==", originalName));
                    const snap = await getDocs(q);
                    const batch = writeBatch(db);
                    snap.forEach(d => batch.update(d.ref, { title: newName, updatedAt: serverTimestamp() }));
                    await batch.commit();
                    PIN_TYPES = PIN_TYPES.map(t => t === originalName ? newName : t);
                    PIN_TYPES.sort();
                    await savePinTypes();
                } else {
                    renderManageList();
                }
            };
            input.onkeydown = (e) => { if (e.key === 'Enter') { input.blur(); } };
            input.onblur = saveRename;
            li.insertBefore(input, nameSpan);
            li.removeChild(nameSpan);
            actionsDiv.style.display = 'none';
            input.focus();
        };
        li.querySelector('.delete-type-btn').onclick = async () => {
            if (!isEditMode) return;
            const q = query(collection(db, COLLECTION_PATH), where("title", "==", type));
            const snap = await getDocs(q);
            const batch = writeBatch(db);
            snap.forEach(d => batch.update(d.ref, { title: "", updatedAt: serverTimestamp() }));
            await batch.commit();
            PIN_TYPES = PIN_TYPES.filter(t => t !== type);
            await savePinTypes();
        };
        list.appendChild(li);
    });
}

// íŒ¨ë„ ë¦¬ì‚¬ì´ì € ê¸°ëŠ¥ ì´ˆê¸°í™”
function initResizer() {
  const resizer = document.getElementById('resizer');
  const panel = document.getElementById('panel');
  let isResizing = false;
  resizer.addEventListener('mousedown', (e) => {
    isResizing = true;
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';
  });
  document.addEventListener('mousemove', (e) => {
    if (!isResizing) return;
    const newWidth = e.clientX;
    if (newWidth > 250 && newWidth < 600) {
      panel.style.width = `${newWidth}px`;
    }
  });
  document.addEventListener('mouseup', () => {
    if (isResizing) {
      isResizing = false;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      map.invalidateSize();
    }
  });
}

/********** 3. ì´ˆê¸°í™” ë° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ **********/
document.addEventListener('DOMContentLoaded', async () => {
  try {
    const { w, h } = await getImageSize(MAP_IMAGE_URL);
    
    map = L.map('map', {
      crs: L.CRS.Simple, 
      minZoom: MIN_ZOOM,
      maxZoom: MAX_ZOOM,
      zoomControl: true, 
      maxBoundsViscosity: 0.9,
    });
    
    L.Control.ResetView = L.Control.extend({
      onAdd: function(map) {
        const btn = L.DomUtil.create('button', 'reset-view-btn');
        btn.innerHTML = 'ğŸŒ';
        btn.title = 'ì „ì²´ ì§€ë„ ë³´ê¸°';
        btn.onclick = () => {
          if (initialBounds) map.fitBounds(initialBounds, { animate: true, duration: 1 });
        };
        return btn;
      },
      onRemove: function(map) {}
    });
    new L.Control.ResetView({ position: 'topright' }).addTo(map);

    initialBounds = [[0,0], [h,w]];
    L.imageOverlay(MAP_IMAGE_URL, initialBounds).addTo(map);
    map.fitBounds(initialBounds);
    map.setMaxBounds(initialBounds);

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    db = getFirestore(app);
    await signInAnonymously(auth);

    initResizer();
    
    onSnapshot(doc(db, COLLECTION_PATH, TYPES_DOC_ID), (docSnap) => {
        if (docSnap.exists()) {
            PIN_TYPES = docSnap.data().list || [];
            PIN_TYPES.sort();
            refreshTypeOptions();
        }
    });

    onSnapshot(query(collection(db, COLLECTION_PATH)), (snap) => {
      snap.docChanges().forEach(ch => {
        if (ch.doc.id === TYPES_DOC_ID) return;
        const { type, doc } = ch;
        if (type === 'added') addMarkerFromDoc(doc.id, doc.data());
        if (type === 'modified') updateMarkerFromDoc(doc.id, doc.data());
        if (type === 'removed') removeMarker(doc.id);
      });
      refreshList(); 
    });

    map.on('click', async (e) => {
      resetAllMarkerStyles(); 
      if (!isEditMode) { selectMarker(null); return; } 
      if (e.originalEvent.target.closest('.leaflet-marker-icon')) return;

      const docRef = await addDoc(collection(db, COLLECTION_PATH), {
        title: '', 
        lat: e.latlng.lat, 
        lng: e.latlng.lng, 
        updatedAt: serverTimestamp()
      });
      selectMarker(docRef.id);
    });

    document.getElementById('editModeSwitch').onchange = (e) => toggleEditMode(e.target.checked);

    document.getElementById('addTypeBtn').onclick = async () => {
        if (!isEditMode) { alert("í¸ì§‘ ëª¨ë“œë¥¼ ì¼œì£¼ì„¸ìš”."); return; }
        const input = document.getElementById('newTypeInput');
        const newType = input.value.trim();
        if (newType && !PIN_TYPES.includes(newType)) {
            PIN_TYPES.push(newType);
            PIN_TYPES.sort();
            await savePinTypes();
            input.value = '';
        } else if (PIN_TYPES.includes(newType)) {
            alert("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì¢…ë¥˜ì…ë‹ˆë‹¤.");
        }
    };
    document.getElementById('newTypeInput').onkeydown = (e) => {
        if (e.key === 'Enter') document.getElementById('addTypeBtn').click();
    };

    document.getElementById('typeSelect').onchange = async (e) => {
      if (!selectedId) return;
      await updateDoc(doc(db, COLLECTION_PATH, selectedId), {
        title: e.target.value, updatedAt: serverTimestamp()
      });
    };
    
    document.getElementById('pinSearchInput').oninput = refreshList;

  } catch (e) {
    document.body.innerHTML = `<div style="padding:20px; color:red">ì˜¤ë¥˜ ë°œìƒ: ${e.message}</div>`;
  }
});

</script>
<style>
/* --- ê¸°ë³¸ ë ˆì´ì•„ì›ƒ --- */
html, body, #app { height: 100%; margin: 0; font-family: sans-serif; overflow: hidden; }
#app { display: flex; flex-direction: row; }
#map { flex: 1; background: #fff; }

#resizer { width: 5px; background: #ddd; cursor: col-resize; z-index: 10; transition: background 0.2s; }
#resizer:hover { background: #bbb; }

#panel {
  width: 320px; display: flex; flex-direction: column;
  background: #f9fafb; z-index: 2;
  min-width: 250px; max-width: 600px;
  border-right: 1px solid #e5e7eb;
}
.panel-header {
  padding: 15px; background: #fff; border-bottom: 1px solid #eee;
  display: flex; justify-content: space-between; align-items: center;
  flex-shrink: 0; 
}
.panel-header h2 { margin: 0; font-size: 18px; color: #333; }
.switch { position: relative; display: inline-block; width: 40px; height: 24px; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider {
  position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
  background-color: #ccc; transition: .4s; border-radius: 34px;
}
.slider:before {
  position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
  background-color: white; transition: .4s; border-radius: 50%;
}
input:checked + .slider { background-color: #2563eb; }
input:checked + .slider:before { transform: translateX(16px); }
.edit-label { font-size: 14px; color: #666; margin-right: 8px; }

/* [ìˆ˜ì •] panel-contentê°€ ìŠ¤í¬ë¡¤ë˜ë„ë¡ */
.panel-content { 
    padding: 15px; 
    flex: 1;
    overflow-y: auto; 
    display: flex; 
    flex-direction: column; 
    gap: 20px; 
    min-height: 0; 
}
.section.pin-list-area {
    /* [ìˆ˜ì •] í•€ ëª©ë¡ ì„¹ì…˜ì´ ë‚¨ì€ ê³µê°„ì„ ì°¨ì§€í•˜ë„ë¡ (PC) */
    flex: 1; 
    display: flex;
    flex-direction: column;
    min-height: 0; /* [ìˆ˜ì •] 0ìœ¼ë¡œ ë³€ê²½ */
}
.section { 
    display: flex; 
    flex-direction: column; 
    gap: 10px;
    flex-shrink: 0; 
}
.section h3 { margin: 0; font-size: 14px; color: #555; border-bottom: 2px solid #eee; padding-bottom: 5px; }

.type-input-group { display: flex; gap: 5px; }
#newTypeInput { flex: 1; }
#typeManageList { list-style: none; padding: 0; margin: 0; max-height: 150px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px; background: #fff; }
#typeManageList li { display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #f5f5f5; font-size: 13px; height: 30px; }
#typeManageList li:last-child { border-bottom: none; }
.type-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.inline-type-input { flex: 1; margin-right: 5px; }
.type-actions button { font-size: 11px; padding: 2px 5px; cursor: pointer; border: 1px solid #ddd; background: #fff; border-radius: 3px; margin-left: 3px; }
.type-actions button:disabled { opacity: 0.5; cursor: not-allowed; }

.edit-form {
  padding: 15px; background: #fff; border-radius: 8px; border: 1px solid #eee;
  display: flex; flex-direction: column; gap: 10px;
  opacity: 0.5; pointer-events: none; transition: opacity 0.3s;
}
#app.edit-mode .edit-form { opacity: 1; pointer-events: auto; }

.search-bar {
  padding: 0;
}
#pinSearchInput {
  width: 100%;
  box-sizing: border-box;
  padding: 6px 8px; 
  border: 1px solid #ddd; 
  border-radius: 4px; 
  font-size: 13px;
}

#pinItems { 
    list-style: none; 
    padding: 0; 
    margin: 0; 
    background: #fff; 
    border: 1px solid #eee; 
    border-radius: 4px; 
    flex: 1; /* [ìˆ˜ì •] ëª©ë¡ì´ ë‚¨ì€ ê³µê°„ ì°¨ì§€ */
    overflow-y: auto; /* [ìˆ˜ì •] ëª©ë¡ ìŠ¤í¬ë¡¤ */
    min-height: 0; /* [ìˆ˜ì •] 0ìœ¼ë¡œ ë³€ê²½ */
}
.pin-group-header {
  display: flex; justify-content: space-between; align-items: center;
  padding: 10px 8px; background: #f3f4f6; cursor: pointer;
  border-bottom: 1px solid #eee; font-weight: bold; font-size: 13px;
}
.pin-group-header:hover { background: #e5e7eb; }
.pin-group-count { font-size: 12px; color: #666; background: #ddd; padding: 2px 6px; border-radius: 10px; }
.pin-group-children { list-style: none; padding-left: 0; margin: 0; }
.pin-group-children.hidden { display: none; }

.pin-child-item {
  padding: 8px 8px 8px 20px; 
  border-bottom: 1px solid #eee; cursor: pointer;
  display: flex; align-items: center; justify-content: space-between; font-size: 13px;
}
.pin-child-item:hover { background: #f9fafb; }
.pin-child-item.active { background: #e0e7ff; color: #2563eb; }
.pin-child-item .title { color: #333; }
.pin-child-item.active .title { color: #2563eb; }

.actions { opacity: 0; transition: opacity 0.2s; }
#app.edit-mode .pin-child-item:hover .actions { opacity: 1; }
.delete-pin-btn { background: none; border: none; cursor: pointer; font-size: 14px; }

input, select, button { padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; }
button { background: #f3f4f6; cursor: pointer; }
button:hover { background: #e5e7eb; }

.marker-root { 
    position: relative; width: 22px; height: 22px; 
    transition: opacity 0.3s ease-in-out; 
}
.marker-dot {
  position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
  width: 14px; height: 14px; background: #2563eb; border: 2px solid #fff; border-radius: 50%;
  box-shadow: 0 0 0 1px #333; transition: all 0.2s;
}
.marker-label {
  position: absolute; top: -24px; left: 50%; transform: translateX(-50%);
  background: rgba(255,255,255,0.8); padding: 2px 6px; border-radius: 4px;
  font-size: 11px; font-weight: bold; white-space: nowrap; pointer-events: none;
  border: 1px solid #ddd;
}
.marker-selected .marker-dot { background: #ef4444; transform: translate(-50%, -50%) scale(1.2); }
.marker-selected { z-index: 999 !important; }

@keyframes marker-blink-animation {
  0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
  50% { opacity: 0.3; transform: translate(-50%, -50%) scale(0.9); }
}
.marker-blink .marker-dot {
  animation: marker-blink-animation 0.5s infinite; 
  background-color: #ef4444 !important; 
}

.marker-faded {
    opacity: 0.3;
    z-index: 1 !important;
}
.marker-faded:hover {
    opacity: 0.8; 
}

.reset-view-btn {
  background-color: #fff;
  border: 2px solid rgba(0,0,0,0.2);
  background-clip: padding-box;
  border-radius: 4px;
  width: 30px; height: 30px; line-height: 30px;
  text-align: center; cursor: pointer; font-size: 18px;
  margin-top: 5px !important; 
}
.reset-view-btn:hover { background-color: #f4f4f4; }
.leaflet-top.leaflet-right { top: 10px; }


@media (max-width: 768px) {
  #app { flex-direction: column; }
  #map { flex: 1; order: 1; }
  #resizer { display: none; }
  #panel {
      width: 100%; height: auto; max-height: 50vh; /* [ìˆ˜ì •] ëª¨ë°”ì¼ íŒ¨ë„ ìµœëŒ€ ë†’ì´ */
      border-right: none; border-top: 1px solid #ddd;
      min-width: auto; max-width: none; order: 2;
  }
  .panel-content { 
      padding: 10px; 
      gap: 15px; 
      flex: 1;
      overflow-y: auto; /* [ìˆ˜ì •] panel-contentê°€ ìœ ì¼í•œ ìŠ¤í¬ë¡¤ ì˜ì—­ì´ ë¨ */
      min-height: 0; 
  }
  #app.edit-mode .actions { opacity: 1; }
  
  .section.pin-list-area {
      flex: 1; /* [ìˆ˜ì •] í•€ ëª©ë¡ ì„¹ì…˜ì´ ë‚¨ì€ ê³µê°„ì„ ì°¨ì§€ */
      min-height: 0; /* [ìˆ˜ì •] 0ìœ¼ë¡œ ë³€ê²½ */
  }
  #pinItems {
      flex: 1; /* [ìˆ˜ì •] í•€ ëª©ë¡ì´ ë‚¨ì€ ê³µê°„ì„ ì°¨ì§€ */
      min-height: 0; /* [ìˆ˜ì •] 0ìœ¼ë¡œ ë³€ê²½ */
      /* max-height: 150px; ì œê±° */
  }
}
</style>
</head>
<body>
<div id="app">
<div id="panel">
<div class="panel-header">
<h2>ğŸŒ¿ ì•ˆë‚´íŒ ìœ„ì¹˜</h2>
<div style="display:flex; align-items:center;">
<span class="edit-label">í¸ì§‘ ëª¨ë“œ</span>
<label class="switch">
<input type="checkbox" id="editModeSwitch">
<span class="slider"></span>
</label>
</div>
</div>

<div class="panel-content">
  <div class="section">
    <h3>ğŸ“Œ ì•ˆë‚´íŒ ì¢…ë¥˜ ê´€ë¦¬</h3>
    <div class="type-input-group">
      <input id="newTypeInput" type="text" placeholder="ìƒˆ ì¢…ë¥˜ ì´ë¦„ ì…ë ¥" />
      <button id="addTypeBtn">ì¶”ê°€</button>
    </div>
    <ul id="typeManageList" class="manage-list"></ul>
  </div>

  <div class="section">
    <h3>ğŸ“ ì„ íƒí•œ í•€ í¸ì§‘</h3>
    <div class="edit-form">
      <select id="typeSelect" disabled>
        <option value="">(í•€ì„ ì„ íƒí•˜ì„¸ìš”)</option>
      </select>
    </div>
  </div>

  <div class="section pin-list-area">
    <h3 style="display: flex; justify-content: space-between; align-items: center;">
        <span>ğŸ“ ë“±ë¡ëœ í•€ ëª©ë¡</span>
        <span style="font-size: 13px; color: #333;">ì´ <span id="totalPinCount" style="font-weight: bold;">0</span>ê°œ</span>
    </h3>
    <div class="search-bar">
      <input type="search" id="pinSearchInput" placeholder="ì¢…ë¥˜ ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰...">
    </div>
    <ul id="pinItems" class="manage-list"></ul>
  </div>

</div>
</div>
<div id="resizer"></div>
<div id="map"></div>
</div>
</body>
</html>
